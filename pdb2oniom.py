#!/usr/bin/env python3
from absl import logging
from absl import app
from absl import flags
from scipy import spatial
from typing import Any, Dict, List, Tuple
import os
import numpy as np
import re
import parmed as pmd

logging.set_verbosity(logging.INFO)


def get_totalcharge(parm) -> int:
    """Calculate total charge"""
    return round(np.sum(parm.parm_data["CHARGE"]))


def writeheader(mem, parmfile, rst7file, outputfile, nproc, near, parm) -> str:
    """write header line"""
    basename_without_ext = os.path.splitext(os.path.basename(outputfile))[0]
    header = f"""%chk={basename_without_ext}.chk
%mem={mem}
%nprocshared={nproc}
#p opt=(quadmac,calcfc,maxstep=10) oniom(pm6:amber=softonly)
scf=qc geom=connectivity nosymm iop(2/15=3) Amber=(FirstEquiv,print)

ONIOM inputfile generated by pdb2oniom.py from {parmfile} and {rst7file}.
Please use GaussView 6 to modify the qm region and add the link atom info.

{get_totalcharge(parm)} 1 0 1 0 1
"""
    return header


def parse_resid(resid) -> List[Tuple[str, int]]:
    """parse corelist provided by argument `resid` and return a tuple of (residuename, residue id)"""
    coreresiduelist = []
    with open(resid) as f:
        lines = [line.strip() for line in f.readlines()]
        for line in lines:
            if line == "":
                continue
            # syntax check for resid file
            resn_resi = re.match(r'^\[(.+)\]\s"([0-9]+)"', line)
            if not resn_resi:
                raise RuntimeError(
                    f"The syntax of '{line}' in {resid} file is not valid."
                )
            else:
                # group(1): residue name, group(2): residue id
                coreresiduelist.append((resn_resi.group(1), int(resn_resi.group(2))))

    return coreresiduelist


def get_qm_and_movable_atomidx(
    resi: list[int],
    near: float,
    parm,
) -> Dict[str, Tuple[List[bool], int]]:
    """
    Return atoms included in QM regions and movable regions.
    If at least one atom in a residue is located within near[Å], all atoms in the residue
    will be included.
    """
    qmatomindexlist = [atom.idx for i in resi for atom in parm.residues[i].atoms]
    neighboratoms = np.any(
        spatial.distance.cdist(parm.coordinates, parm.coordinates[qmatomindexlist[:]])
        <= near,
        axis=1,
    )
    neighborresidueatomidx = [
        atom.idx
        for residue in set(
            [parm.atoms[i].residue for i in list(neighboratoms.nonzero()[0])]
        )
        for atom in residue.atoms
    ]
    neighborresidueatoms = [False] * len(parm.atoms)
    for i in neighborresidueatomidx:
        neighborresidueatoms[i] = True

    nbra_count = np.count_nonzero(neighborresidueatoms)

    return {
        "qm": (qmatomindexlist, len(qmatomindexlist)),
        "movable": (neighborresidueatoms, nbra_count),
    }


def getflag(resid, near, parm) -> Dict[str, List[Any]]:
    """get atom indices of movable (-1 or 0) and Low/High-layer (L or H) for writecoordinatesinfo"""
    resi_list = []
    resnresilist = []
    for resn, resi in parse_resid(resid):
        if parm.residues[resi - 1].name != resn:
            raise ValueError(
                f"'{resn}-{resi}' in '{resid}' is not found in the input parm7 and rst7 file."
            )
        resi_list.append(resi - 1)
        resnresilist.append(f"{resn}{resi}")
    return {
        "qm": get_qm_and_movable_atomidx(resi_list, near, parm)["qm"][0],
        "movable": get_qm_and_movable_atomidx(resi_list, near, parm)["movable"][0],
    }


def fixatomtype(atom_type) -> str:
    """fix undesired atom type such as 2C, 3C, C*, N*,... to read from Gaussian 16.
    Lowercase atom types (e.g. gaff2 force field) are converted to uppercase"""
    atom_type = str(atom_type)
    if atom_type == "2C":
        return "C2C"
    elif atom_type == "3C":
        return "C3C"
    elif atom_type == "C*":
        return "C9"
    elif atom_type == "N*":
        return "N9"
    elif bool(re.match(r"^[a-z]+", atom_type)):
        return f"L{atom_type.upper()}"
    else:
        return atom_type


def writecoordinatesinfo(resid, near, parm) -> Tuple[str, str]:
    """write coordinates section"""
    coordsinfo = ""
    onbinfo = ""
    qmflag = ["L"] * len(parm.atoms)
    movableflag = [
        0 if i is True else -1 for i in getflag(resid, near, parm)["movable"]
    ]
    movableatomcount = movableflag.count(0)
    logging.info(
        f"{movableatomcount} atoms are set to be movable during geometry optimization."
    )
    for i in getflag(resid, near, parm)["qm"]:
        qmflag[i] = "H"
    for atom in parm.atoms:
        x, y, z = atom.xx, atom.xy, atom.xz
        atomsection = (
            f"{atom.element_name}-{fixatomtype(atom.atom_type)}-{atom.charge:.6f}"
        )
        coordsinfo += f"{atomsection:<16} {movableflag[atom.idx]:>2}   {x:8.03f}  {y:8.03f}  {z:8.03f} {qmflag[atom.idx]}\n"
        onbinfo += f"{atomsection:<16} {movableflag[atom.idx]:>2}   {x:8.03f}  {y:8.03f}  {z:8.03f}  L    {atom.name:>4} {atom.residue.name:>4} {atom.residue.number + 1}\n"
    return coordsinfo, onbinfo


def writebondinfo(parm) -> str:
    """Write bond info section"""
    bondpairs = sorted([[bonds.atom1.idx, bonds.atom2.idx] for bonds in parm.bonds])
    pre = -1
    bondinfo = ""
    for bondpair in bondpairs:
        if bondpair[0] > pre:
            if bondpair[0] > pre + 1:
                for i in range(pre + 1, bondpair[0]):
                    bondinfo += f"\n{i+1}"
            bondinfo += f"\n{bondpair[0]+1} {bondpair[1]+1} 1.0 "
            pre = bondpair[0]
        else:
            bondinfo += f"{bondpair[1]+1} 1.0 "
    for j in range(pre + 1, bondpairs[-1][1] + 1):
        bondinfo += f"\n{j+1}"
    bondinfo += "\n\n"
    return bondinfo


def writehrmstr1section(parm):
    hrmstr1list = []
    hrmstr1info = ""
    hrmstr1_tuple = set(
        (
            fixatomtype(bonds.atom1.atom_type),
            fixatomtype(bonds.atom2.atom_type),
            bonds.type.k,
            bonds.type.req,
        )
        for bonds in parm.bonds
    )
    for i in hrmstr1_tuple:
        # delete duplicate definitions
        if (i[1], i[0], i[2], i[3]) in hrmstr1list:
            continue
        else:
            hrmstr1list.append(i)
    hrmstr1list = sorted(hrmstr1list)
    for j in hrmstr1list:
        hrmstr1info += f"HrmStr1  {j[0]:>3} {j[1]:>3}  {j[2]:>6}  {j[3]:>6}\n"
    # TODO: assert the line number of hrmstr1info matches the number of parm.parm_data["BOND_FORCE_CONSTANT"] (109)
    return hrmstr1info


def writehrmbnd1section(parm):
    hrmbnd1list = []
    hrmbnd1info = ""
    hrmbnd1_tuple = set(
        (
            fixatomtype(angles.atom1.atom_type),
            fixatomtype(angles.atom2.atom_type),
            fixatomtype(angles.atom3.atom_type),
            angles.type.k,
            format(angles.type.theteq, ".3f"),
        )
        for angles in parm.angles
    )
    for i in hrmbnd1_tuple:
        # delete duplicate definitions
        if (i[2], i[1], i[0], i[3], i[4]) in hrmbnd1list:
            continue
        else:
            hrmbnd1list.append(i)
    hrmbnd1list = sorted(hrmbnd1list)
    for j in hrmbnd1list:
        hrmbnd1info += (
            f"HrmBnd1  {j[0]:>3} {j[1]:>3} {j[2]:>3}  {j[3]:>6}   {j[4]:>6}\n"
        )

    # add HW OW info
    hrmbnd1info += "HrmBnd1   HW  OW  HW   0.000    0.0000\n"
    hrmbnd1info += "HrmBnd1   HW  HW  OW   0.000    0.0000\n"
    return hrmbnd1info


def get_unique_list(seq):
    """Remove duplicates for multiple arrays"""
    seen = []
    non_dep_dihedlist = []
    tmplist = [x for x in seq if x not in seen and not seen.append(x)]
    for i in tmplist:
        # delete duplicate definitions
        if [
            (i[0][3], i[0][2], i[0][1], i[0][0]),
            (i[1][0], i[1][1]),
            i[2],
            i[3],
        ] in non_dep_dihedlist:
            continue
        else:
            non_dep_dihedlist.append(i)
    return non_dep_dihedlist


def writetorsionsection(parm):
    """Write dihedral sections: AmbTrs and ImpTrs
    dihed_list = [[('LC', 'LC', 'LN', 'LHN'), (180, '1.1000'), 2, True/False], [...], ]
    dihedrals.improper==False -> AmbTrs, True -> ImpTrs
    """
    torsioninfo = ""
    ambtrsinfo = []
    improperinfo = []
    diheds_list = [
        [
            (
                fixatomtype(dihedrals.atom1.atom_type),
                fixatomtype(dihedrals.atom2.atom_type),
                fixatomtype(dihedrals.atom3.atom_type),
                fixatomtype(dihedrals.atom4.atom_type),
            ),
            (int(dihedrals.type.phase), "{:.4f}".format(dihedrals.type.phi_k)),
            dihedrals.type.per,
            dihedrals.improper,
        ]
        for dihedrals in parm.dihedrals
    ]
    # remove duplicate definition
    diheds_list = get_unique_list(diheds_list)

    for diheds in diheds_list:
        if not diheds[3]:
            if diheds[0] not in [x[0] for x in ambtrsinfo]:
                ambtrsinfo.append(
                    [
                        diheds[0],
                        [0, 0, 0, 0],
                        ["0.0000", "0.0000", "0.0000", "0.0000"],
                        1.0,
                    ]
                )
            ambtrsinfo1 = [x[0] for x in ambtrsinfo]
            num = ambtrsinfo1.index(diheds[0])
            ambtrsinfo[num][1][diheds[2] - 1] = diheds[1][0]
            ambtrsinfo[num][2][diheds[2] - 1] = diheds[1][1]
        else:
            if diheds[0] not in [x[0] for x in improperinfo]:
                improperinfo.append([diheds[0], 0.00, 0.000, 0.0])
            improperinfo1 = [x[0] for x in improperinfo]
            num = improperinfo1.index(diheds[0])
            improperinfo[num][1] = diheds[1][1]
            improperinfo[num][2] = diheds[1][0]
            improperinfo[num][3] = diheds[2]

    for i in ambtrsinfo:
        torsioninfo += (
            f"AmbTrs  {i[0][0]:>3} {i[0][1]:>3} {i[0][2]:>3} {i[0][3]:>3} "
            f"{i[1][0]:>4} {i[1][1]:>4} {i[1][2]:>4} {i[1][3]:>4}   "
            f"{i[2][0]}  {i[2][1]}  {i[2][2]}  {i[2][3]}   1.0\n"
        )

    for i in improperinfo:
        torsioninfo += f"ImpTrs  {i[0][0]:>3} {i[0][1]:>3} {i[0][2]:>3} {i[0][3]:>3}   {i[1]:>8}   {i[2]:.01f}   {i[3]:.01f}\n"
    return torsioninfo


def writevdwsection(parm) -> str:
    vdwinfo = ""
    vdw_list = []
    vdw_list = [
        [
            fixatomtype(atom.atom_type),
            format(atom.rmin, ".4f"),
            format(atom.epsilon, ".4f"),
        ]
        for atom in parm.atoms
    ]
    seen = []
    tmplist = [x for x in vdw_list if x not in seen and not seen.append(x)]
    for i in tmplist:
        vdwinfo += f"VDW {i[0]:>3} {i[1]} {i[2]}\n"
    # Add Nonbon term
    # See also: https://gaussian.com/mm/
    # -> Specifying Force Fields -> The Non-Bonded Interaction Master Function
    vdwinfo += "NonBon 3 1 0 0  0.00  0.00  0.50  0.00  0.00  -1.2\n"
    return vdwinfo


def writegjffile(
    parmfile: str,
    rst7file: str,
    resid: str,
    near: float = 999.0,
    outputfile: str = "oniominput1.gjf",
    mem: str = "60GB",
    nproc: int = 16,
) -> None:
    """main process"""

    logging.info(
        "pdb2oniom.py ver.0.2; Amber parm and rst7 files to Gaussian ONIOM input file."
    )
    parm = pmd.load_file(parmfile, xyz=rst7file)
    logging.info(f"Total charge of low layer is calculated {get_totalcharge(parm)}")
    logging.info(f"Core residues list file {resid} provided.")
    logging.info(
        f"All residues within {near} Å from core region are free to move (0) during geometry optimization."
    )
    coordsinfo, onbinfo = writecoordinatesinfo(resid, near, parm)
    desc = ""
    desc += writeheader(mem, parmfile, rst7file, outputfile, nproc, near, parm)
    desc += coordsinfo
    desc += writebondinfo(parm)
    desc += writehrmstr1section(parm)
    desc += writehrmbnd1section(parm)
    desc += writetorsionsection(parm)
    desc += writevdwsection(parm)
    logging.info(f"Opening file {outputfile} for output ...")
    with open(outputfile, "w") as f:
        f.write(desc)
    logging.info(f"Successfully wrote {outputfile} file.")
    logging.info(f"Opening file {outputfile}.onb for output ...")
    onbfile = f"{outputfile}.onb"
    with open(onbfile, "w") as f:
        f.write(onbinfo)
    logging.info(f"Successfully wrote {outputfile}.onb file.")
    logging.info("pdb2oniom.py ends.\n")
    logging.info(
        "NOTE: The charges and multiplicity of high layer should be modified for your calculations. "
        "Please use GaussView 6 to modify the QM regions and link atoms."
    )


flags.DEFINE_string("parmfile", None, "Path to input parm7 file.", short_name="p")
flags.DEFINE_string(
    "rst7file",
    None,
    "Path to input rst7 file that must be consistent with input parm7",
    short_name="r",
)
flags.DEFINE_string(
    "resid",
    None,
    "listfile. File containing the list of core residues. The distance between atoms "
    "and these core residues will be used to set up the optimization flags. "
    'The format of file is [Residue Name] "Residue ID", e.g.: '
    'The file must be [ALA] "1"\n[HID] "288"\n...',
)
flags.DEFINE_float(
    "near",
    999.0,
    "number is in Angstroms. Any residue with at least one atom within "
    "this distance of any atom in the core residues will be free to move "
    "during the optimization process (with flag 0 in the Gaussian ONIOM job file). "
    "Default is 999.0 Å.",
    short_name="n",
)
flags.DEFINE_string(
    "outputfile",
    "newinput.gjf",
    "File name of the output gjf file. Default is newinput.gjf.",
    short_name="o",
)
flags.DEFINE_string(
    "mem",
    "60GB",
    "Memory value that will be printed in the output gjf file. Default is 60GB.",
)
flags.DEFINE_integer(
    "nproc",
    16,
    "Number of processor (nprocshared) that will be printed in the output gjf file. Default is 16.",
)

FLAGS = flags.FLAGS


def main(argv):
    if len(argv) > 1:
        raise app.UsageError("Too many command-line arguments.")
    if FLAGS.near < 0:
        raise ValueError("The near argument must be 0 or more.")
    if FLAGS.nproc < 1:
        raise ValueError("The nproc argument must be 1 or more.")
    parmfile = FLAGS.parmfile
    rst7file = FLAGS.rst7file
    resid = FLAGS.resid
    near = FLAGS.near
    outputfile = FLAGS.outputfile
    mem = FLAGS.mem
    nproc = FLAGS.nproc
    writegjffile(parmfile, rst7file, resid, near, outputfile, mem, nproc)


if __name__ == "__main__":
    flags.mark_flags_as_required(
        [
            "parmfile",
            "rst7file",
            "resid",
        ]
    )

    app.run(main)
